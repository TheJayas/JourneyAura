{"version":3,"sources":["../src/atomProvider.ts","../src/atomWithFn.ts","../src/createAtomProvider.tsx","../src/useHydrateStore.ts","../src/createAtomStore.ts"],"sourcesContent":["import React from 'react';\nimport { Provider } from 'jotai';\n\nexport type AtomProviderProps = React.ComponentProps<typeof Provider>;\n\nexport { Provider as AtomProvider } from 'jotai';\n","import { atom } from 'jotai';\n\nimport type { WritableAtom } from 'jotai/vanilla';\n\ntype WrapFn<T> = T extends (...args: infer _A) => infer _R ? { __fn: T } : T;\n\nconst wrapFn = <T>(fnOrValue: T): WrapFn<T> =>\n  (typeof fnOrValue === 'function' ? { __fn: fnOrValue } : fnOrValue) as any;\n\ntype UnwrapFn<T> = T extends { __fn: infer U } ? U : T;\n\nconst unwrapFn = <T>(wrappedFnOrValue: T): UnwrapFn<T> =>\n  (wrappedFnOrValue &&\n  typeof wrappedFnOrValue === 'object' &&\n  '__fn' in wrappedFnOrValue\n    ? wrappedFnOrValue.__fn\n    : wrappedFnOrValue) as any;\n\n/**\n * Jotai atoms don't allow functions as values by default. This function is a\n * drop-in replacement for `atom` that wraps functions in an object while\n * leaving non-functions unchanged. The wrapper object should be completely\n * invisible to consumers of the atom.\n */\nexport const atomWithFn = <T>(initialValue: T): WritableAtom<T, [T], void> => {\n  const baseAtom = atom(wrapFn(initialValue));\n\n  return atom(\n    (get) => unwrapFn(get(baseAtom)) as T,\n    (_get, set, value) => set(baseAtom, wrapFn(value))\n  );\n};\n","import React from 'react';\nimport { createStore } from 'jotai/vanilla';\n\nimport { AtomProvider, AtomProviderProps } from './atomProvider';\nimport { JotaiStore, SimpleWritableAtomRecord } from './createAtomStore';\nimport { useHydrateStore, useSyncStore } from './useHydrateStore';\n\nconst getFullyQualifiedScope = (storeName: string, scope: string) => {\n  return `${storeName}:${scope}`;\n};\n\n/**\n * Context mapping store name and scope to store. The 'provider' scope is used\n * to reference any provider belonging to the store, regardless of scope.\n */\nconst PROVIDER_SCOPE = 'provider';\nconst AtomStoreContext = React.createContext<Map<string, JotaiStore>>(\n  new Map()\n);\n\n/**\n * Tries to find a store in each of the following places, in order:\n * 1. The store context, matching the store name and scope\n * 2. The store context, matching the store name and 'provider' scope\n * 3. Otherwise, return undefined\n */\nexport const useAtomStore = (\n  storeName: string,\n  scope: string = PROVIDER_SCOPE,\n  warnIfUndefined: boolean = true\n): JotaiStore | undefined => {\n  const storeContext = React.useContext(AtomStoreContext);\n  const store =\n    storeContext.get(getFullyQualifiedScope(storeName, scope)) ??\n    storeContext.get(getFullyQualifiedScope(storeName, PROVIDER_SCOPE));\n\n  if (!store && warnIfUndefined) {\n    console.warn(\n      `Tried to access jotai store '${storeName}' outside of a matching provider.`\n    );\n  }\n\n  return store;\n};\n\nexport type ProviderProps<T extends object> = AtomProviderProps &\n  Partial<T> & {\n    scope?: string;\n    initialValues?: Partial<T>;\n    resetKey?: any;\n  };\n\nexport const HydrateAtoms = <T extends object>({\n  initialValues,\n  children,\n  store,\n  atoms,\n  ...props\n}: Omit<ProviderProps<T>, 'scope'> & {\n  atoms: SimpleWritableAtomRecord<T>;\n}) => {\n  useHydrateStore(atoms, { ...initialValues, ...props } as any, {\n    store,\n  });\n  useSyncStore(atoms, props as any, {\n    store,\n  });\n\n  return <>{children}</>;\n};\n\n/**\n * Creates a generic provider for a jotai store.\n * - `initialValues`: Initial values for the store.\n * - `props`: Dynamic values for the store.\n */\nexport const createAtomProvider = <T extends object, N extends string = ''>(\n  storeScope: N,\n  atoms: SimpleWritableAtomRecord<T>,\n  options: { effect?: React.FC } = {}\n) => {\n  const Effect = options.effect;\n\n  // eslint-disable-next-line react/display-name\n  return ({ store, scope, children, resetKey, ...props }: ProviderProps<T>) => {\n    const [storeState, setStoreState] =\n      React.useState<JotaiStore>(createStore());\n\n    React.useEffect(() => {\n      if (resetKey) {\n        setStoreState(createStore());\n      }\n    }, [resetKey]);\n\n    const previousStoreContext = React.useContext(AtomStoreContext);\n\n    const storeContext = React.useMemo(() => {\n      const newStoreContext = new Map(previousStoreContext);\n\n      if (scope) {\n        // Make the store findable by its fully qualified scope\n        newStoreContext.set(\n          getFullyQualifiedScope(storeScope, scope),\n          storeState\n        );\n      }\n\n      // Make the store findable by its store name alone\n      newStoreContext.set(\n        getFullyQualifiedScope(storeScope, PROVIDER_SCOPE),\n        storeState\n      );\n\n      return newStoreContext;\n    }, [previousStoreContext, scope, storeState]);\n\n    return (\n      <AtomStoreContext.Provider value={storeContext}>\n        <AtomProvider store={storeState}>\n          <HydrateAtoms store={storeState} atoms={atoms} {...(props as any)}>\n            {!!Effect && <Effect />}\n\n            {children}\n          </HydrateAtoms>\n        </AtomProvider>\n      </AtomStoreContext.Provider>\n    );\n  };\n};\n","import React from 'react';\nimport { useSetAtom } from 'jotai';\nimport { useHydrateAtoms } from 'jotai/utils';\n\nimport {\n  SimpleWritableAtomRecord,\n  UseHydrateAtoms,\n  UseSyncAtoms,\n} from './createAtomStore';\n\n/**\n * Hydrate atoms with initial values for SSR.\n */\nexport const useHydrateStore = (\n  atoms: SimpleWritableAtomRecord<any>,\n  initialValues: Parameters<UseHydrateAtoms<any>>[0],\n  options: Parameters<UseHydrateAtoms<any>>[1] = {}\n) => {\n  const values: any[] = [];\n\n  for (const key of Object.keys(atoms)) {\n    const initialValue = initialValues[key];\n\n    if (initialValue !== undefined) {\n      values.push([atoms[key], initialValue]);\n    }\n  }\n\n  useHydrateAtoms(values, options);\n};\n\n/**\n * Update atoms with new values on changes.\n */\nexport const useSyncStore = (\n  atoms: SimpleWritableAtomRecord<any>,\n  values: any,\n  { store }: Parameters<UseSyncAtoms<any>>[1] = {}\n) => {\n  for (const key of Object.keys(atoms)) {\n    const value = values[key];\n    const atom = atoms[key];\n\n    const set = useSetAtom(atom, { store });\n\n    React.useEffect(() => {\n      if (value !== undefined && value !== null) {\n        set(value);\n      }\n    }, [set, value]);\n  }\n};\n","import React from 'react';\nimport { useAtom, useAtomValue, useSetAtom } from 'jotai';\nimport { useHydrateAtoms } from 'jotai/utils';\n\nimport { atomWithFn } from './atomWithFn';\nimport { createAtomProvider, useAtomStore } from './createAtomProvider';\n\nimport type { ProviderProps } from './createAtomProvider';\nimport type { Atom, createStore, WritableAtom } from 'jotai/vanilla';\n\nexport type JotaiStore = ReturnType<typeof createStore>;\n\nexport type UseAtomOptions = {\n  scope?: string;\n  store?: JotaiStore;\n  delay?: number;\n  warnIfNoStore?: boolean;\n};\n\ntype UseAtomOptionsOrScope = UseAtomOptions | string;\n\ntype GetRecord<O> = {\n  [K in keyof O]: O[K] extends Atom<infer V>\n    ? (options?: UseAtomOptionsOrScope) => V\n    : never;\n};\n\ntype SetRecord<O> = {\n  [K in keyof O]: O[K] extends WritableAtom<infer _V, infer A, infer R>\n    ? (options?: UseAtomOptionsOrScope) => (...args: A) => R\n    : never;\n};\n\ntype UseRecord<O> = {\n  [K in keyof O]: O[K] extends WritableAtom<infer V, infer A, infer R>\n    ? (options?: UseAtomOptionsOrScope) => [V, (...args: A) => R]\n    : never;\n};\n\ntype StoreAtomsWithoutExtend<T> = {\n  [K in keyof T]: T[K] extends Atom<any> ? T[K] : SimpleWritableAtom<T[K]>;\n};\n\ntype ValueTypesForAtoms<T> = {\n  [K in keyof T]: T[K] extends Atom<infer V> ? V : never;\n};\n\ntype StoreInitialValues<T> = ValueTypesForAtoms<StoreAtomsWithoutExtend<T>>;\n\ntype StoreAtoms<T, E> = StoreAtomsWithoutExtend<T> & E;\n\ntype FilterWritableAtoms<T> = {\n  [K in keyof T]-?: T[K] extends WritableAtom<any, any, any> ? T[K] : never;\n};\n\ntype WritableStoreAtoms<T, E> = FilterWritableAtoms<StoreAtoms<T, E>>;\n\nexport type SimpleWritableAtom<T> = WritableAtom<T, [T], void>;\n\nexport type SimpleWritableAtomRecord<T> = {\n  [K in keyof T]: SimpleWritableAtom<T[K]>;\n};\n\nexport type AtomRecord<O> = {\n  [K in keyof O]: Atom<O[K]>;\n};\n\ntype UseNameStore<N extends string = ''> = `use${Capitalize<N>}Store`;\ntype NameStore<N extends string = ''> = N extends '' ? 'store' : `${N}Store`;\ntype NameProvider<N extends string = ''> = `${Capitalize<N>}Provider`;\nexport type UseHydrateAtoms<T> = (\n  initialValues: Partial<Record<keyof T, any>>,\n  options?: Parameters<typeof useHydrateAtoms>[1]\n) => void;\nexport type UseSyncAtoms<T> = (\n  values: Partial<Record<keyof T, any>>,\n  options?: {\n    store?: JotaiStore;\n  }\n) => void;\n\nexport type StoreApi<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n> = {\n  atom: StoreAtoms<T, E>;\n  name: N;\n};\n\ntype GetAtomFn = <V>(atom: Atom<V>, options?: UseAtomOptionsOrScope) => V;\n\ntype SetAtomFn = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>,\n  options?: UseAtomOptionsOrScope\n) => (...args: A) => R;\n\ntype UseAtomFn = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>,\n  options?: UseAtomOptionsOrScope\n) => [V, (...args: A) => R];\n\nexport type UseStoreApi<T, E> = (options?: UseAtomOptionsOrScope) => {\n  get: GetRecord<StoreAtoms<T, E>> & { atom: GetAtomFn };\n  set: SetRecord<WritableStoreAtoms<T, E>> & { atom: SetAtomFn };\n  use: UseRecord<WritableStoreAtoms<T, E>> & { atom: UseAtomFn };\n  store: (options?: UseAtomOptionsOrScope) => JotaiStore | undefined;\n};\n\nexport type AtomStoreApi<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n> = {\n  name: N;\n} & {\n  [key in keyof Record<NameProvider<N>, object>]: React.FC<\n    ProviderProps<StoreInitialValues<T>>\n  >;\n} & {\n  [key in keyof Record<NameStore<N>, object>]: StoreApi<T, E, N>;\n} & {\n  [key in keyof Record<UseNameStore<N>, object>]: UseStoreApi<T, E>;\n};\n\nconst capitalizeFirstLetter = (str = '') =>\n  str.length > 0 ? str[0].toUpperCase() + str.slice(1) : '';\nconst getProviderIndex = (name = '') =>\n  `${capitalizeFirstLetter(name)}Provider`;\nconst getStoreIndex = (name = '') =>\n  name.length > 0 ? `${name}Store` : 'store';\nconst getUseStoreIndex = (name = '') =>\n  `use${capitalizeFirstLetter(name)}Store`;\n\nconst isAtom = (possibleAtom: unknown): boolean =>\n  !!possibleAtom &&\n  typeof possibleAtom === 'object' &&\n  'read' in possibleAtom &&\n  typeof possibleAtom.read === 'function';\n\nconst withDefaultOptions = <T extends object>(\n  fnRecord: T,\n  defaultOptions: UseAtomOptions\n): T =>\n  Object.fromEntries(\n    Object.entries(fnRecord).map(([key, fn]) => [\n      key,\n      (options: UseAtomOptions = {}) =>\n        (fn as any)({ ...defaultOptions, ...options }),\n    ])\n  ) as any;\n\nconst convertScopeShorthand = (\n  optionsOrScope: UseAtomOptionsOrScope = {}\n): UseAtomOptions =>\n  typeof optionsOrScope === 'string'\n    ? { scope: optionsOrScope }\n    : optionsOrScope;\n\nexport interface CreateAtomStoreOptions<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string,\n> {\n  name: N;\n  delay?: UseAtomOptions['delay'];\n  effect?: React.FC;\n  extend?: (atomsWithoutExtend: StoreAtomsWithoutExtend<T>) => E;\n}\n\n/**\n * Create an atom store from an initial value.\n * Each property will have a getter and setter.\n *\n * @example\n * const { exampleStore, useExampleStore } = createAtomStore({ count: 1, say: 'hello' }, { name: 'example' as const })\n * const [count, setCount] = useExampleStore().use.count()\n * const say = useExampleStore().get.say()\n * const setSay = useExampleStore().set.say()\n * setSay('world')\n * const countAtom = exampleStore.atom.count\n */\nexport const createAtomStore = <\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n>(\n  initialState: T,\n  { name, delay: delayRoot, effect, extend }: CreateAtomStoreOptions<T, E, N>\n): AtomStoreApi<T, E, N> => {\n  type MyStoreAtoms = StoreAtoms<T, E>;\n  type MyWritableStoreAtoms = WritableStoreAtoms<T, E>;\n  type MyStoreAtomsWithoutExtend = StoreAtomsWithoutExtend<T>;\n  type MyWritableStoreAtomsWithoutExtend =\n    FilterWritableAtoms<MyStoreAtomsWithoutExtend>;\n  type MyStoreInitialValues = StoreInitialValues<T>;\n\n  const providerIndex = getProviderIndex(name) as NameProvider<N>;\n  const useStoreIndex = getUseStoreIndex(name) as UseNameStore<N>;\n  const storeIndex = getStoreIndex(name) as NameStore<N>;\n\n  const atomsWithoutExtend = {} as MyStoreAtomsWithoutExtend;\n  const writableAtomsWithoutExtend = {} as MyWritableStoreAtomsWithoutExtend;\n  const atomIsWritable = {} as Record<keyof MyStoreAtoms, boolean>;\n\n  for (const [key, atomOrValue] of Object.entries(initialState)) {\n    const atomConfig: Atom<unknown> = isAtom(atomOrValue)\n      ? atomOrValue\n      : atomWithFn(atomOrValue);\n    atomsWithoutExtend[key as keyof MyStoreAtomsWithoutExtend] =\n      atomConfig as any;\n\n    const writable = 'write' in atomConfig;\n    atomIsWritable[key as keyof MyStoreAtoms] = writable;\n\n    if (writable) {\n      writableAtomsWithoutExtend[\n        key as keyof MyWritableStoreAtomsWithoutExtend\n      ] = atomConfig as any;\n    }\n  }\n\n  const atoms = { ...atomsWithoutExtend } as MyStoreAtoms;\n\n  if (extend) {\n    const extendedAtoms = extend(atomsWithoutExtend);\n\n    for (const [key, atomConfig] of Object.entries(extendedAtoms)) {\n      atoms[key as keyof MyStoreAtoms] = atomConfig;\n      atomIsWritable[key as keyof MyStoreAtoms] = 'write' in atomConfig;\n    }\n  }\n\n  const getAtoms = {} as GetRecord<MyStoreAtoms>;\n  const setAtoms = {} as SetRecord<MyWritableStoreAtoms>;\n  const useAtoms = {} as UseRecord<MyWritableStoreAtoms>;\n\n  const useStore = (optionsOrScope: UseAtomOptionsOrScope = {}) => {\n    const {\n      scope,\n      store,\n      warnIfNoStore = true,\n    } = convertScopeShorthand(optionsOrScope);\n    const contextStore = useAtomStore(name, scope, !store && warnIfNoStore);\n    return store ?? contextStore;\n  };\n\n  const useAtomValueWithStore: GetAtomFn = (atomConfig, optionsOrScope) => {\n    const options = convertScopeShorthand(optionsOrScope);\n    const store = useStore({ warnIfNoStore: false, ...options });\n    return useAtomValue(atomConfig, {\n      store,\n      delay: options.delay ?? delayRoot,\n    });\n  };\n\n  const useSetAtomWithStore: SetAtomFn = (atomConfig, optionsOrScope) => {\n    const store = useStore(optionsOrScope);\n    return useSetAtom(atomConfig, { store });\n  };\n\n  const useAtomWithStore: UseAtomFn = (atomConfig, optionsOrScope) => {\n    const store = useStore(optionsOrScope);\n    const { delay = delayRoot } = convertScopeShorthand(optionsOrScope);\n    return useAtom(atomConfig, { store, delay });\n  };\n\n  for (const key of Object.keys(atoms)) {\n    const atomConfig = atoms[key as keyof MyStoreAtoms];\n    const isWritable: boolean = atomIsWritable[key as keyof MyStoreAtoms];\n\n    (getAtoms as any)[key] = (optionsOrScope: UseAtomOptionsOrScope = {}) =>\n      useAtomValueWithStore(atomConfig, optionsOrScope);\n\n    if (isWritable) {\n      (setAtoms as any)[key] = (optionsOrScope: UseAtomOptionsOrScope = {}) =>\n        useSetAtomWithStore(\n          atomConfig as WritableAtom<any, any, any>,\n          optionsOrScope\n        );\n\n      (useAtoms as any)[key] = (optionsOrScope: UseAtomOptionsOrScope = {}) =>\n        useAtomWithStore(\n          atomConfig as WritableAtom<any, any, any>,\n          optionsOrScope\n        );\n    }\n  }\n\n  const Provider: React.FC<ProviderProps<MyStoreInitialValues>> =\n    createAtomProvider<MyStoreInitialValues, N>(\n      name,\n      writableAtomsWithoutExtend,\n      { effect }\n    );\n\n  const storeApi: StoreApi<T, E, N> = {\n    atom: atoms,\n    name,\n  };\n\n  const useStoreApi: UseStoreApi<T, E> = (defaultOptions = {}) => ({\n    get: {\n      ...withDefaultOptions(getAtoms, convertScopeShorthand(defaultOptions)),\n      atom: (atomConfig, options) =>\n        useAtomValueWithStore(atomConfig, {\n          ...convertScopeShorthand(defaultOptions),\n          ...convertScopeShorthand(options),\n        }),\n    },\n    set: {\n      ...withDefaultOptions(setAtoms, convertScopeShorthand(defaultOptions)),\n      atom: (atomConfig, options) =>\n        useSetAtomWithStore(atomConfig, {\n          ...convertScopeShorthand(defaultOptions),\n          ...convertScopeShorthand(options),\n        }),\n    },\n    use: {\n      ...withDefaultOptions(useAtoms, convertScopeShorthand(defaultOptions)),\n      atom: (atomConfig, options) =>\n        useAtomWithStore(atomConfig, {\n          ...convertScopeShorthand(defaultOptions),\n          ...convertScopeShorthand(options),\n        }),\n    },\n    store: (options) =>\n      useStore({\n        ...convertScopeShorthand(defaultOptions),\n        ...convertScopeShorthand(options),\n      }),\n  });\n\n  return {\n    [providerIndex]: Provider,\n    [useStoreIndex]: useStoreApi,\n    [storeIndex]: storeApi,\n    name,\n  } as any;\n};\n"],"mappings":"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","names":["React","atom","React","useSetAtom","useSetAtom","Provider"]}