import { Value, TEditor, TNode, TDescendant, TText, EText } from '@udecode/slate';
import { ReactEditor, RenderLeafProps } from 'slate-react';
import * as slate from 'slate';
import { Path, Location, Point, Range } from 'slate';
import * as slate_react_dist_utils_key from 'slate-react/dist/utils/key';
import * as slate_react_dist_utils_dom from 'slate-react/dist/utils/dom';
import { DOMNode, DOMPoint } from 'slate-react/dist/utils/dom';
import { Value as Value$1 } from '@udecode/slate/dist';
import React$1 from 'react';
import { UnknownObject, Modify } from '@udecode/utils';

type TReactEditor<V extends Value = Value> = TEditor<V> & Pick<ReactEditor, 'insertData' | 'insertFragmentData' | 'insertTextData' | 'setFragmentData' | 'hasRange' | 'hasTarget' | 'hasEditableTarget' | 'hasSelectableTarget' | 'isTargetInsideNonReadonlyVoid'>;

/**
 * Blur the editor.
 */
declare const blurEditor: <V extends Value>(editor: TReactEditor<V>) => void;

/**
 * Deselect the editor.
 */
declare const deselectEditor: <V extends Value>(editor: TReactEditor<V>) => void;

/**
 * Find the DOM node that implements DocumentOrShadowRoot for the editor.
 */
declare const findEditorDocumentOrShadowRoot: <V extends Value>(editor: TReactEditor<V>) => Document | ShadowRoot | undefined;

/**
 * {@link ReactEditor.findEventRange}
 */
declare const findEventRange: <V extends Value>(editor: TReactEditor<V>, event: any) => slate.BaseRange | undefined;

/**
 * Find a key for a Slate node.
 */
declare const findNodeKey: <V extends Value>(editor: TReactEditor<V>, node: TNode) => slate_react_dist_utils_key.Key | undefined;

/**
 * Find the path of Slate node.
 */
declare const findNodePath: <V extends Value>(editor: TReactEditor<V>, node: TNode) => Path | undefined;

/**
 * Focus the editor. Extension:
 *
 * If `target` is defined:
 * - deselect the editor (otherwise it will focus the start of the editor)
 * - select the editor
 * - focus the editor
 */
declare const focusEditor: <V extends Value>(editor: TReactEditor<V>, target?: Location) => void;

/**
 * Return the host window of the current editor.
 */
declare const getEditorWindow: <V extends Value>(editor: TReactEditor<V>) => Window | undefined;

/**
 * Check if a DOM node is within the editor.
 */
declare const hasEditorDOMNode: <V extends Value>(editor: TReactEditor<V>, target: DOMNode, options?: Parameters<typeof ReactEditor.hasDOMNode>[2]) => boolean;

/**
 * Check if the target is editable and in the editor.
 */
declare const hasEditorEditableTarget: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => target is Node;

/**
 * Check if the target can be selectable.
 */
declare const hasEditorSelectableTarget: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => boolean;

/**
 * Check if the target is in the editor.
 */
declare const hasEditorTarget: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => target is Node;

/**
 * Insert data from a `DataTransfer` into the editor.
 */
declare const insertData: <V extends Value>(editor: TReactEditor<V>, data: DataTransfer) => void;

/**
 * Check if the user is currently composing inside the editor.
 */
declare const isComposing: <V extends Value>(editor: TReactEditor<V>) => boolean;

/**
 * Check if the editor is focused.
 */
declare const isEditorFocused: <V extends Value>(editor: TReactEditor<V>) => boolean;

/**
 * Check if the editor is in read-only mode.
 */
declare const isEditorReadOnly: <V extends Value>(editor: TReactEditor<V>) => boolean;

/**
 * Check if the target is inside void and in an non-readonly editor.
 */
declare const isTargetInsideNonReadonlyVoid: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => boolean;

/**
 * Sets data from the currently selected fragment on a `DataTransfer`.
 */
declare const setFragmentData: <V extends Value>(editor: TReactEditor<V>, data: DataTransfer) => void;

/**
 * Find the native DOM element from a Slate node.
 */
declare const toDOMNode: <V extends Value>(editor: TReactEditor<V>, node: TNode) => HTMLElement | undefined;

/**
 * Find a native DOM selection point from a Slate point.
 */
declare const toDOMPoint: <V extends Value>(editor: TReactEditor<V>, point: Point) => slate_react_dist_utils_dom.DOMPoint | undefined;

/**
 * {@link ReactEditor.toDOMRange}
 */
declare const toDOMRange: <V extends Value$1>(editor: TReactEditor<V>, range: Range) => globalThis.Range | undefined;

/**
 * {@link ReactEditor.toSlateNode}
 */
declare const toSlateNode: <V extends Value>(editor: TReactEditor<V>, domNode: DOMNode) => TNode | undefined;

/**
 * {@link ReactEditor.toSlatePoint}
 */
declare const toSlatePoint: <V extends Value>(editor: TReactEditor<V>, domPoint: DOMPoint, options: Parameters<typeof ReactEditor.toSlatePoint>[2]) => slate.BasePoint | null | undefined;

/**
 * {@link ReactEditor.toSlateRange}
 */
declare const toSlateRange: <V extends Value>(editor: TReactEditor<V>, domRange: Parameters<typeof ReactEditor.toSlateRange>[1], options: Parameters<typeof ReactEditor.toSlateRange>[2]) => slate.BaseRange | null | undefined;

interface SlateProps extends UnknownObject {
    editor: ReactEditor;
    value: TDescendant[];
    children: React$1.ReactNode;
    onChange: (value: SlateProps['value']) => void;
}

type TRenderLeafProps<V extends Value = Value, N extends TText = EText<V>> = Modify<RenderLeafProps, {
    leaf: N;
    text: N;
}>;
type RenderLeafFn<V extends Value = Value> = (props: TRenderLeafProps<V>) => React.ReactElement;

/**
 * Focus an editor edge.
 */
declare const focusEditorEdge: <V extends Value>(editor: TReactEditor<V>, { edge, }?: {
    edge?: "end" | "start" | undefined;
}) => void;

export { RenderLeafFn, SlateProps, TReactEditor, TRenderLeafProps, blurEditor, deselectEditor, findEditorDocumentOrShadowRoot, findEventRange, findNodeKey, findNodePath, focusEditor, focusEditorEdge, getEditorWindow, hasEditorDOMNode, hasEditorEditableTarget, hasEditorSelectableTarget, hasEditorTarget, insertData, isComposing, isEditorFocused, isEditorReadOnly, isTargetInsideNonReadonlyVoid, setFragmentData, toDOMNode, toDOMPoint, toDOMRange, toSlateNode, toSlatePoint, toSlateRange };
