import * as _udecode_slate from '@udecode/slate';
import { EDescendant, Value, TEditor, FindNodeOptions, TNodeEntry, EAncestor, GetAboveNodeOptions, ChildOf, TNode, EElementOrText, EAncestorEntry, TOperation, EElement, QueryNodeOptions, TAncestor, QueryEditorOptions, TElement, InsertNodesOptions, ENodeEntry, SetNodesOptions, RemoveNodesOptions, EMarks, WrapNodesOptions, TDescendant } from '@udecode/slate';
import * as slate from 'slate';
import { Path, Point, Location, Range } from 'slate';
import { Modify } from '@udecode/utils';

/**
 * Iterate through all of the nodes in the editor and return the first match. If
 * no match is found, return undefined.
 */

/**
 * Get the first descendant node matching the condition.
 */
declare const findDescendant: <N extends EDescendant<V>, V extends Value = Value>(editor: TEditor<V>, options: FindNodeOptions<V>) => TNodeEntry<N> | undefined;

/**
 * Get the block above a location (default: selection).
 */
declare const getBlockAbove: <N extends EAncestor<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V>) => _udecode_slate.TNodeEntry<N> | undefined;

/**
 * Get children node entries of a node entry.
 * TODO: try Node.children
 */
declare const getChildren: <N extends ChildOf<R>, R extends TNode = TNode>(nodeEntry: TNodeEntry<R>) => TNodeEntry<N>[];

/**
 * Get the edge blocks above a location (default: selection).
 */
declare const getEdgeBlocksAbove: <N1 extends EAncestor<V>, N2 extends EAncestor<V> = N1, V extends Value = Value>(editor: TEditor<V>, { at: _at, ...options }?: GetAboveNodeOptions<V>) => [TNodeEntry<N1>, TNodeEntry<N2>] | null;

/**
 * Get the last child of a node or null if no children.
 */
declare const getLastChild: <N extends ChildOf<R>, R extends TNode>(nodeEntry: TNodeEntry<R>) => TNodeEntry<N> | null;
/**
 * Get last child path. If there is no child, last index is 0.
 */
declare const getLastChildPath: <N extends TNode>(nodeEntry: TNodeEntry<N>) => Path;
/**
 * Is the child path the last one of the parent.
 */
declare const isLastChild: <N extends TNode>(parentEntry: TNodeEntry<N>, childPath: Path) => boolean;

/**
 * Get the last node at a given level.
 */
declare const getLastNodeByLevel: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, level: number) => TNodeEntry<N> | undefined;

/**
 * Get selection mark value by key.
 */
declare const getMark: <V extends Value>(editor: TEditor<V>, key: string) => unknown;

/**
 * Get the start point of the next node.
 */
declare const getNextNodeStartPoint: <V extends Value = Value>(editor: TEditor<V>, at: Path) => slate.BasePoint | undefined;

/**
 * Get the next sibling nodes after a path.
 * @param ancestorEntry Ancestor of the sibling nodes
 * @param path Path of the reference node
 */
declare const getNextSiblingNodes: <V extends Value>(ancestorEntry: EAncestorEntry<V>, path: Path) => EElementOrText<V>[];

/**
 * Get typed editor operations.
 */
declare const getOperations: <V extends Value>(editor: TEditor<V>) => TOperation<EDescendant<V>>[];

interface BeforeOptions {
    distance?: number | undefined;
    unit?: 'character' | 'word' | 'line' | 'block' | 'offset' | undefined;
}
interface PointBeforeOptions extends BeforeOptions {
    /**
     * Lookup before the location for `matchString`.
     */
    matchString?: string | string[];
    /**
     * Lookup before the location until this predicate is true
     */
    match?: (value: {
        beforeString: string;
        beforePoint: Point;
        at: Location;
    }) => boolean;
    /**
     * If true, get the point after the matching point.
     * If false, get the matching point.
     */
    afterMatch?: boolean;
    /**
     * If true, lookup until the start of the editor value.
     * If false, lookup until the first invalid character.
     */
    skipInvalid?: boolean;
}
/**
 * {@link getPointBefore} with additional options.
 * TODO: support for sequence of any characters.
 */
declare const getPointBeforeLocation: <V extends Value>(editor: TEditor<V>, at: Location, options?: PointBeforeOptions) => any;

/**
 * Get the point from a location (default: selection).
 * If the location is a range, get the anchor point.
 * If the location is a path, get the point at this path with offset 0.
 * If `focus` is true, get the focus point.
 */
declare const getPointFromLocation: <V extends Value>(editor: TEditor<V>, { at, focus, }?: {
    at?: Location | null | undefined;
    focus?: boolean | undefined;
}) => slate.BasePoint | undefined;

/**
 * If the start point is inside an inline void, get the point before or after it.
 */
declare const getPointNextToVoid: <V extends Value>(editor: TEditor<V>, { at, after, }: {
    at: Point;
    /**
     * Get the point after (instead of before) the void node.
     */
    after?: boolean | undefined;
}) => slate.BasePoint;

/**
 * Find the block before a block by id.
 * If not found, find the first block by id and return [null, its previous path]
 */
declare const getPreviousBlockById: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, id: string, query?: QueryNodeOptions) => TNodeEntry<N> | undefined;

/**
 * Get the end point of the previous node.
 */
declare const getPreviousNodeEndPoint: <V extends Value = Value>(editor: TEditor<V>, at: Path) => slate.BasePoint | undefined;

declare const getPreviousPath: (path: Path) => Path | undefined;

declare const getPreviousSiblingNode: <V extends Value = Value>(editor: TEditor<V>, path: Path) => (number[] | _udecode_slate.NodeOf<TEditor<V>>)[] | undefined;

interface RangeBeforeOptions extends PointBeforeOptions {
}
/**
 * Get range from {@link getPointBeforeLocation} to the end point of `at`.
 */
declare const getRangeBefore: <V extends Value>(editor: TEditor<V>, at: Location, options?: RangeBeforeOptions) => Range | undefined;

/**
 * Get the range from the start of the block above a location (default: selection) to the location.
 */
declare const getRangeFromBlockStart: <V extends Value>(editor: TEditor<V>, options?: Omit<GetAboveNodeOptions<V>, "match">) => {
    anchor: slate.BasePoint;
    focus: slate.BasePoint;
} | undefined;

/**
 * Get the selected text.
 * Return empty string if no selection.
 */
declare const getSelectionText: <V extends Value>(editor: TEditor<V>) => string;

/**
 * Is an ancestor empty (empty text and no inline children).
 */
declare const isAncestorEmpty: <V extends Value>(editor: TEditor<V>, node: TAncestor) => boolean;

/**
 * Is the block above the selection empty.
 */
declare const isBlockAboveEmpty: <V extends Value>(editor: TEditor<V>) => boolean;

/**
 * Is there empty text after the selection.
 * If there is no leaf after the selected leaf, return {@link isEndPoint}.
 * Else, check if the next leaves are empty.
 */
declare const isBlockTextEmptyAfterSelection: <V extends Value>(editor: TEditor<V>) => boolean;

declare const isDocumentEnd: <V extends Value = Value>(editor: TEditor<V>) => boolean;

/**
 * Whether the editor is empty. An editor is empty if it has only one empty element.
 */
declare const isEditorEmpty: <V extends Value>(editor: TEditor<V>) => boolean;

/**
 * Is it the first child of the parent
 */
declare const isFirstChild: (path: Path) => boolean;

/**
 * Is the mark defined in the selection.
 */
declare const isMarkActive: <V extends Value>(editor: TEditor<V>, type: string) => boolean;

/**
 * Is a point at the end of a word
 */
declare const isPointAtWordEnd: <V extends Value>(editor: TEditor<V>, { at }: {
    at: Point;
}) => boolean;

/**
 * Is the range (default: selection) across blocks.
 * - return undefined if block not found
 * - return boolean whether one of the block is not found, but the other is found
 * - return boolean whether block paths are unequal
 */
declare const isRangeAcrossBlocks: <V extends Value>(editor: TEditor<V>, { at, ...options }?: Omit<GetAboveNodeOptions<V>, "at"> & {
    at?: slate.BaseRange | null | undefined;
}) => boolean | undefined;

/**
 * Whether the range is in the same block.
 */
declare const isRangeInSameBlock: <V extends Value>(editor: TEditor<V>, { at, ...options }?: Omit<GetAboveNodeOptions<V>, "at"> & {
    at?: slate.BaseRange | null | undefined;
}) => boolean | undefined;

/**
 * Is the range in the same single text path.
 */
declare const isRangeInSingleText: (at: Range) => boolean;

/**
 * Is the selection focus at the end of its parent block.
 */
declare const isSelectionAtBlockEnd: <V extends Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V> | undefined) => boolean;

/**
 * Is the selection anchor or focus at the start of its parent block.
 *
 * Supports the same options provided by {@link getBlockAbove}.
 */
declare const isSelectionAtBlockStart: <V extends Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V> | undefined) => boolean;

/**
 * Is the selection expanded.
 */
declare const isSelectionExpanded: <V extends Value>(editor: TEditor<V>) => boolean;

declare const isTextByPath: <V extends Value>(editor: TEditor<V>, path: Path) => boolean;

/**
 * Is the word at the point after a trigger (punctuation character)
 * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6
 */
declare const isWordAfterTrigger: <V extends Value>(editor: TEditor<V>, { at, trigger }: {
    at: Point;
    trigger: string;
}) => {
    range: slate.BaseRange | undefined;
    match: RegExpMatchArray | null;
};

/**
 * Query the editor state.
 */
declare const queryEditor: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(editor: E, { filter, selectionAtBlockStart, selectionAtBlockEnd, allow, exclude, at, }?: QueryEditorOptions<V, E>) => boolean;

declare const insertElements: <V extends Value>(editor: TEditor<V>, nodes: TElement | TElement[], options?: InsertNodesOptions<V> | undefined) => void;

declare const insertEmptyElement: <V extends Value>(editor: TEditor<V>, type: string, options?: InsertNodesOptions<V> | undefined) => void;

interface MoveChildrenOptions<V extends Value = Value> {
    /**
     * Parent node of the children to move.
     */
    at: ENodeEntry<V> | Path;
    /**
     * Path where to move the children.
     */
    to: Path;
    /**
     * Start index of the children to move.
     * Example: 1 means children[0] will not be moved.
     */
    fromStartIndex?: number;
    /**
     * Condition for the child to be moved
     */
    match?(entry: ENodeEntry<V>): boolean;
}
/**
 * Move the children of a node to a path.
 * Returns the number of children moved.
 */
declare const moveChildren: <V extends Value>(editor: TEditor<V>, { at, to, match, fromStartIndex }: MoveChildrenOptions<V>) => number;

interface RemoveMarkOptions<V extends Value = Value> extends Omit<SetNodesOptions<V>, 'match' | 'split'> {
    /**
     * Mark or the array of marks that will be removed
     */
    key: string | string[];
    /**
     * When location is not a Range,
     * setting this to false can prevent the onChange event of the editor to fire
     * @default true
     */
    shouldChange?: boolean;
    /**
     * Range where the mark(s) will be removed
     */
    at?: Range;
}
/**
 * Remove mark and trigger `onChange` if collapsed selection.
 */
declare const removeMark: <V extends Value>(editor: TEditor<V>, { key, at, shouldChange, ...rest }: RemoveMarkOptions<V>) => void;

/**
 * Remove selection marks.
 */
declare const removeSelectionMark: <V extends Value = Value>(editor: TEditor<V>) => void;

interface ReplaceNodeChildrenOptions<N extends EElementOrText<V>, V extends Value = Value> {
    at: Path;
    nodes: N | N[];
    removeOptions?: Omit<RemoveNodesOptions<V>, 'at'>;
    insertOptions?: Omit<InsertNodesOptions<V>, 'at'>;
}
/**
 * Replace node children: remove then insert.
 */
declare const replaceNodeChildren: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, { at, nodes, insertOptions, removeOptions }: ReplaceNodeChildrenOptions<N, V>) => void;

declare const replaceNode: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, { at, nodes, insertOptions, removeOptions }: ReplaceNodeChildrenOptions<N, V>) => void;

/**
 * Select the end point of the block above the selection.
 */
declare const selectEndOfBlockAboveSelection: <V extends Value>(editor: TEditor<V>) => void;

/**
 * Set marks to selected text.
 */
declare const setMarks: <V extends Value>(editor: TEditor<V>, marks: EMarks<V>, clear?: string | string[]) => void;

interface ToggleMarkOptions {
    clear?: string | string[];
    key: string;
}
/**
 * Add/remove marks in the selection.
 * @param editor
 * @param key mark to toggle
 * @param clear marks to clear when adding mark
 */
declare const toggleMark: <V extends Value = Value>(editor: TEditor<V>, { key, clear }: ToggleMarkOptions) => void;

/**
 * Unwrap if the node type is in selection.
 * Wrap otherwise.
 */
declare const toggleWrapNodes: <V extends Value>(editor: TEditor<V>, type: string) => void;

/**
 * Wrap node children into a single element:
 * - wraps the first child node into the element
 * - move the other child nodes next to the element children.
 */
declare const wrapNodeChildren: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, element: N, options: Modify<WrapNodesOptions<V>, {
    at: Path;
}>) => void;

declare const createDocumentNode: (type?: string, text?: string, remaining?: TDescendant[]) => TDescendant[];

declare const createNode: (type?: string, text?: string) => TElement;

export { BeforeOptions, MoveChildrenOptions, PointBeforeOptions, RangeBeforeOptions, RemoveMarkOptions, ReplaceNodeChildrenOptions, ToggleMarkOptions, createDocumentNode, createNode, findDescendant, getBlockAbove, getChildren, getEdgeBlocksAbove, getLastChild, getLastChildPath, getLastNodeByLevel, getMark, getNextNodeStartPoint, getNextSiblingNodes, getOperations, getPointBeforeLocation, getPointFromLocation, getPointNextToVoid, getPreviousBlockById, getPreviousNodeEndPoint, getPreviousPath, getPreviousSiblingNode, getRangeBefore, getRangeFromBlockStart, getSelectionText, insertElements, insertEmptyElement, isAncestorEmpty, isBlockAboveEmpty, isBlockTextEmptyAfterSelection, isDocumentEnd, isEditorEmpty, isFirstChild, isLastChild, isMarkActive, isPointAtWordEnd, isRangeAcrossBlocks, isRangeInSameBlock, isRangeInSingleText, isSelectionAtBlockEnd, isSelectionAtBlockStart, isSelectionExpanded, isTextByPath, isWordAfterTrigger, moveChildren, queryEditor, removeMark, removeSelectionMark, replaceNode, replaceNodeChildren, selectEndOfBlockAboveSelection, setMarks, toggleMark, toggleWrapNodes, wrapNodeChildren };
