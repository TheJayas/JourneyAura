import { UnknownObject, Simplify, UnionToIntersection, Modify } from '@udecode/utils';
import * as slate from 'slate';
import { Path, Location, Range, Selection, Span, Editor, Point, EditorLevelsOptions, NodeAncestorsOptions, NodeChildrenOptions, NodeDescendantsOptions, NodeElementsOptions, NodeLevelsOptions, NodeTextsOptions, NodeNodesOptions, EditorNextOptions, EditorUnhangRangeOptions, EditorNodesOptions, EditorNodeOptions, EditorParentOptions, EditorPathOptions, EditorPointOptions, EditorAfterOptions, EditorBeforeOptions, EditorPositionsOptions, EditorPreviousOptions, EditorVoidOptions, EditorNormalizeOptions, Transforms } from 'slate';
import { EditorPathRefOptions, EditorPointRefOptions, EditorRangeRefOptions, EditorDirectedDeletionOptions, EditorFragmentDeletionOptions, EditorAboveOptions, EditorStringOptions, EditorLeafOptions } from 'slate/dist/interfaces/editor';
import { HistoryEditor } from 'slate-history';
import { SelectionCollapseOptions, SelectionMoveOptions, SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';
import { TextDeleteOptions, TextInsertFragmentOptions, TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';

/**
 * `Text` objects represent the nodes that contain the actual text content of a
 * Slate document along with any formatting properties. They are always leaf
 * nodes in the document tree as they cannot contain any children.
 */
type TText = UnknownObject & {
    text: string;
};
/**
 * Text node of an editor.
 */
type EText<V extends Value> = TextOf<TEditor<V>>;
/**
 * A utility type to get all the text node types from a root node type.
 */
type TextOf<N extends TNode> = TEditor extends N ? TText : TElement extends N ? TText : N extends TEditor ? TextOf<N['children'][number]> : N extends TElement ? Extract<N['children'][number], TText> | TextOf<N['children'][number]> : N extends TText ? N : never;
/**
 * A utility type to get all the mark types from a root node type.
 */
type MarksOf<N extends TNode> = Simplify<UnionToIntersection<TNodeProps<TextOf<N>>>>;
type EMarks<V extends Value> = MarksOf<TEditor<V>>;
type MarkKeysOf<N extends TNode> = {} extends MarksOf<N> ? unknown : keyof MarksOf<N>;

type TNode = TEditor | TElement | TText;
/**
 * Node of an editor.
 */
type ENode<V extends Value> = NodeOf<TEditor<V>>;
/**
 * A utility type to get all the node types from a root node type.
 */
type NodeOf<N extends TNode> = N | ElementOf<N> | TextOf<N>;
/**
 * Convenience type for returning the props of a node.
 */
type TNodeProps<N extends TNode> = N extends TEditor ? Omit<N, 'children'> : N extends TElement ? Omit<N, 'children'> : Omit<N, 'text'>;
/**
 * A helper type for narrowing matched nodes with a predicate.
 */
type TNodeMatch<N extends TNode = TNode> = ((node: N, path: Path) => node is N) | ((node: N, path: Path) => boolean);

/**
 * `Element` objects are a type of node in a Slate document that contain other
 * element nodes or text nodes. They can be either "blocks" or "inlines"
 * depending on the Slate editor's configuration.
 */
type TElement = UnknownObject & {
    children: TDescendant[];
    type: string;
};
/**
 * Element of an editor.
 */
type EElement<V extends Value> = ElementOf<TEditor<V>>;
/**
 * Element or text of an editor. Differs from EDescendant<V>.
 */
type EElementOrText<V extends Value> = EElement<V> | EText<V>;
/**
 * `ElementEntry` objects refer to an `Element` and the `Path` where it can be
 * found inside a root node.
 */
/**
 * A utility type to get all the element nodes type from a root node.
 */
type ElementOf<N extends TNode> = TEditor extends N ? TElement : TElement extends N ? TElement : N extends TEditor ? Extract<N['children'][number], TElement> | ElementOf<N['children'][number]> : N extends TElement ? N | Extract<N['children'][number], TElement> | ElementOf<N['children'][number]> : never;

/**
 * The `Descendant` union type represents nodes that are descendants in the
 * tree. It is returned as a convenience in certain cases to narrow a value
 * further than the more generic `Node` union.
 */
type TDescendant = TElement | TText;
/**
 * Descendant of an editor.
 */
type EDescendant<V extends Value> = DescendantOf<TEditor<V>>;
/**
 * A utility type to get all the descendant node types from a root node type.
 */
type DescendantOf<N extends TNode> = N extends TEditor ? ElementOf<N> | TextOf<N> : N extends TElement ? ElementOf<N['children'][number]> | TextOf<N> : never;
/**
 * A utility type to get the child node types from a root node type.
 */
type ChildOf<N extends TNode, I extends number = number> = N extends TEditor ? N['children'][I] : N extends TElement ? N['children'][I] : never;
declare const isDescendant: (value: any) => value is TDescendant;

type TLocation = Location;
type TPath = Path;
type TRange = Range;
type TSelection = Selection;
type TSpan = Span;

type TInsertNodeOperation<N extends TDescendant = TDescendant> = {
    type: 'insert_node';
    path: TPath;
    node: N;
    [key: string]: unknown;
};
type TInsertTextOperation = {
    type: 'insert_text';
    path: TPath;
    offset: number;
    text: string;
    [key: string]: unknown;
};
type TMergeNodeOperation = {
    type: 'merge_node';
    path: TPath;
    position: number;
    properties: object;
    [key: string]: unknown;
};
type TMoveNodeOperation = {
    type: 'move_node';
    path: TPath;
    newPath: TPath;
    [key: string]: unknown;
};
type TRemoveNodeOperation<N extends TDescendant = TDescendant> = {
    type: 'remove_node';
    path: TPath;
    node: N;
    [key: string]: unknown;
};
type TRemoveTextOperation = {
    type: 'remove_text';
    path: TPath;
    offset: number;
    text: string;
    [key: string]: unknown;
};
type TSetNodeOperation = {
    type: 'set_node';
    path: TPath;
    properties: object;
    newProperties: object;
    [key: string]: unknown;
};
type TSetSelectionOperation = {
    type: 'set_selection';
    properties: null;
    newProperties: TRange;
    [key: string]: unknown;
} | {
    type: 'set_selection';
    properties: Partial<TRange>;
    newProperties: Partial<TRange>;
    [key: string]: unknown;
} | {
    type: 'set_selection';
    properties: TRange;
    newProperties: null;
    [key: string]: unknown;
};
type TSplitNodeOperation = {
    type: 'split_node';
    path: TPath;
    position: number;
    properties: object;
    [key: string]: unknown;
};
type TNodeOperation<N extends TDescendant = TDescendant> = TInsertNodeOperation<N> | TMergeNodeOperation | TMoveNodeOperation | TRemoveNodeOperation<N> | TSetNodeOperation | TSplitNodeOperation;
type TSelectionOperation = TSetSelectionOperation;
type TTextOperation = TInsertTextOperation | TRemoveTextOperation;
/**
 * `Operation` objects define the low-level instructions that Slate editors use
 * to apply changes to their internal state. Representing all changes as
 * operations is what allows Slate editors to easily implement history,
 * collaboration, and other features.
 */
type TOperation<N extends TDescendant = TDescendant> = TNodeOperation<N> | TSelectionOperation | TTextOperation;

/**
 * The `Ancestor` union type represents nodes that are ancestors in the tree.
 * It is returned as a convenience in certain cases to narrow a value further
 * than the more generic `Node` union.
 */
type TAncestor = TEditor | TElement;
/**
 * Ancestor of an editor.
 */
type EAncestor<V extends Value> = AncestorOf<TEditor<V>>;
/**
 * A utility type to get all the ancestor node types from a root node type.
 */
type AncestorOf<N extends TNode> = TEditor extends N ? TEditor | TElement : TElement extends N ? TElement : N extends TEditor ? N | N['children'][number] | ElementOf<N['children'][number]> : N extends TElement ? N | ElementOf<N> : never;

/**
 * `TNodeEntry` objects are returned when iterating over the nodes in a Slate
 * document tree. They consist of the node and its `Path` relative to the root
 * node in the document.
 */
type TNodeEntry<N extends TNode = TNode> = [N, Path];
/**
 * Node entry from an editor.
 */
type ENodeEntry<V extends Value> = TNodeEntry<ENode<V>>;
/**
 * Element entry from a node.
 */
type TElementEntry<N extends TNode = TNode> = TNodeEntry<ElementOf<N>>;
/**
 * Element entry from an editor.
 */
/**
 * Element entry of a value.
 */
type EElementEntry<V extends Value> = TNodeEntry<EElement<V>>;
/**
 * Text node entry from a node.
 */
type TTextEntry<N extends TNode = TNode> = TNodeEntry<TextOf<N>>;
/**
 * Text node entry from an editor.
 */
/**
 * Text node entry of a value.
 */
type ETextEntry<V extends Value> = TNodeEntry<EText<V>>;
/**
 * Ancestor entry from a node.
 */
type TAncestorEntry<N extends TNode = TNode> = TNodeEntry<AncestorOf<N>>;
/**
 * Ancestor entry from an editor.
 */
type EAncestorEntry<V extends Value> = TAncestorEntry<TEditor<V>>;
/**
 * Descendant entry from a node.
 */
type TDescendantEntry<N extends TNode = TNode> = TNodeEntry<DescendantOf<N>>;
/**
 * Descendant entry from an editor.
 */
/**
 * Descendant entry of a value.
 */
type EDescendantEntry<V extends Value> = TNodeEntry<EDescendant<V>>;
/**
 * Child node entry from a node.
 */
type TNodeChildEntry<N extends TNode = TNode> = TNodeEntry<ChildOf<N>>;

type Value = TElement[];
/**
 * A helper type for getting the value of an editor.
 */
type ValueOf<E extends TEditor> = E['children'];
type TEditor<V extends Value = Value> = Modify<Editor, {
    id: any;
    children: V;
    operations: TOperation[];
    marks: Record<string, any> | null;
    isInline: <N extends TElement>(element: N) => boolean;
    isVoid: <N extends TElement>(element: N) => boolean;
    markableVoid: <N extends TElement>(element: N) => boolean;
    normalizeNode: <N extends TNode>(entry: TNodeEntry<N>) => void;
    apply: <N extends TDescendant>(operation: TOperation<N>) => void;
    getFragment: <N extends TDescendant>() => N[];
    insertFragment: <N extends TDescendant>(fragment: N[]) => void;
    insertNode: <N extends TDescendant>(node: N) => void;
    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];
}> & UnknownObject;
/**
 * Get editor with typed methods and operations.
 * Note that it can't be used as a parameter of type TEditor.
 */
declare const getTEditor: <V extends Value, E extends TEditor<V> = TEditor<V>>(editor: E) => Modify<E, {
    operations: TOperation<EElementOrText<V>>[];
    isInline: (element: EElement<V>) => boolean;
    isVoid: (element: EElement<V>) => boolean;
    normalizeNode: (entry: TNodeEntry<ENode<V>>) => void;
    apply: (operation: TOperation<EElementOrText<V>>) => void;
    getFragment: () => EElementOrText<V>[];
    insertFragment: (fragment: EElementOrText<V>[]) => void;
    insertNode: (node: EElementOrText<V> | EElementOrText<V>[]) => void;
}>;

declare const createTEditor: <V extends Value>() => TEditor<V>;

/**
 * Add a custom property to the leaf text nodes in the current selection.
 *
 * If the selection is currently collapsed, the marks will be added to the
 * `editor.marks` property instead, and applied when text is inserted next.
 */
declare const addMark: <V extends Value>(editor: TEditor<V>, key: string, value: any) => void;

/**
 * Create a mutable ref for a `Path` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createPathRef: <V extends Value>(editor: TEditor<V>, at: Path, options?: EditorPathRefOptions) => slate.PathRef;

/**
 * Create a mutable ref for a `Point` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createPointRef: <V extends Value>(editor: TEditor<V>, point: Point, options?: EditorPointRefOptions) => slate.PointRef;

/**
 * Create a mutable ref for a `Range` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createRangeRef: <V extends Value>(editor: TEditor<V>, range: Range, options?: EditorRangeRefOptions) => slate.RangeRef;

/**
 * Delete content in the editor backward from the current selection.
 */
declare const deleteBackward: <V extends Value>(editor: TEditor<V>, options?: EditorDirectedDeletionOptions) => void;

/**
 * Delete content in the editor forward from the current selection.
 */
declare const deleteForward: <V extends Value>(editor: TEditor<V>, options?: EditorDirectedDeletionOptions) => void;

/**
 * Delete the content in the current selection.
 */
declare const deleteFragment: <V extends Value>(editor: TEditor<V>, options?: EditorFragmentDeletionOptions) => void;

declare const deleteMerge: <V extends Value>(editor: TEditor<V>, options?: {
    at?: Location;
    distance?: number;
    unit?: 'character' | 'word' | 'line' | 'block';
    reverse?: boolean;
    hanging?: boolean;
    voids?: boolean;
    test?: any;
}) => void;

type PredicateObj = Record<string, any | any[]>;
type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;
type Predicate<T extends TNode> = PredicateObj | PredicateFn<T>;
/**
 * Match the object with a predicate object or function.
 * If predicate is:
 * - object: every predicate key/value should be in obj.
 * - function: it should return true.
 */
declare const match: <T extends TNode>(obj: T, path: slate.Path, predicate?: Predicate<T> | undefined) => boolean;
/**
 * Extended query options for slate queries:
 * - `match` can be an object predicate where one of the values should include the node value.
 * Example: { type: ['1', '2'] } will match the nodes having one of these 2 types.
 */
declare const getQueryOptions: <V extends Value>(editor: TEditor<V>, options?: any) => any;
type ENodeMatch<N extends TNode> = Predicate<N>;
interface ENodeMatchOptions<V extends Value = Value> {
    match?: ENodeMatch<ENode<V>>;
    block?: boolean;
}

type GetAboveNodeOptions<V extends Value = Value> = Modify<NonNullable<EditorAboveOptions<TAncestor>>, ENodeMatchOptions<V>>;
/**
 * Get the ancestor above a location in the document.
 */
declare const getAboveNode: <N extends EAncestor<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V> | undefined) => TNodeEntry<N> | undefined;

/**
 * Get the start and end points of a location.
 */
declare const getEdgePoints: <V extends Value>(editor: TEditor<V>, at: Location) => [slate.BasePoint, slate.BasePoint];

/**
 * Get the text string content of a location.
 *
 * Note: by default the text of void nodes is considered to be an empty
 * string, regardless of content, unless you pass in true for the voids option
 */
declare const getEditorString: <V extends Value>(editor: TEditor<V>, at: Location | null | undefined, options?: EditorStringOptions) => string;

/**
 * Get the end point of a location.
 */
declare const getEndPoint: <V extends Value>(editor: TEditor<V>, at: Location) => slate.BasePoint;

/**
 * Get the first node at a location.
 */
declare const getFirstNode: <V extends Value>(editor: TEditor<V>, at: Location) => ENodeEntry<V>;

/**
 * Get the fragment at a location.
 */
declare const getFragment: <V extends Value>(editor: TEditor<V>, at: Location) => EElementOrText<V>[];

/**
 * Get the last node at a location.
 */
declare const getLastNode: <V extends Value>(editor: TEditor<V>, at: Location) => ENodeEntry<V>;

/**
 * Get the leaf text node at a location.
 */
declare const getLeafNode: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorLeafOptions) => ETextEntry<V>;

type GetLevelsOptions<V extends Value = Value> = Modify<NonNullable<EditorLevelsOptions<TNode>>, {
    match?: TNodeMatch<ENode<V>>;
}>;
/**
 * Iterate through all of the levels at a location.
 */
declare const getLevels: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetLevelsOptions<V> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Get the marks that would be added to text at the current selection.
 */
declare const getMarks: <V extends Value>(editor: TEditor<V>) => EMarks<V> | null;

/**
 * Get an entry for the common ancesetor node of two paths.
 */
declare const getCommonNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path, another: Path) => TNodeEntry<N>;

/**
 * Get the descendant node referred to by a specific path.
 * If the path is an empty array, it refers to the root node itself.
 * If the node is not found, return null.
 * Based on Slate get and has, performance optimization without overhead of
 * stringify on throwing
 */
declare const getNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => N | null;

/**
 * Get the node at a specific path, asserting that it's an ancestor node.
 */
declare const getNodeAncestor: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of all the ancestor nodes above a specific path.
 *
 * By default the order is bottom-up, from lowest to highest ancestor in
 * the tree, but you can pass the `reverse: true` option to go top-down.
 */
declare const getNodeAncestors: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeAncestorsOptions) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Get the child of a node at a specific index.
 */
declare const getNodeChild: <N extends ChildOf<R, I>, R extends TNode = TNode, I extends number = number>(root: R, index: I) => N;

/**
 * Iterate over the children of a node at a specific path.
 */
declare const getNodeChildren: <N extends ChildOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeChildrenOptions) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Get the node at a specific path, asserting that it's a descendant node.
 */
declare const getNodeDescendant: <N extends DescendantOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of all the descendant node entries inside a root node.
 */
declare const getNodeDescendants: <N extends DescendantOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeDescendantsOptions, {
    pass?: ((node: TDescendantEntry<N>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Return a generator of all the element nodes inside a root node. Each iteration
 * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
 * root node is an element it will be included in the iteration as well.
 */
declare const getNodeElements: <N extends ElementOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeElementsOptions, {
    pass?: ((node: TElementEntry<N>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Get the first node entry in a root node from a path.
 */
declare const getNodeFirstNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => TNodeEntry<N>;

/**
 * Get the sliced fragment represented by a range inside a root node.
 */
declare const getNodeFragment: <N extends ElementOf<R> | TextOf<R>, R extends TNode = TNode>(root: R, range: Range) => N[];

/**
 * Get the last node entry in a root node from a path.
 */
declare const getNodeLastNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => TNodeEntry<N>;

/**
 * Get the node at a specific path, ensuring it's a leaf text node.
 */
declare const getNodeLeaf: <N extends TextOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of the in a branch of the tree, from a specific path.
 *
 * By default the order is top-down, from lowest to highest node in the tree,
 * but you can pass the `reverse: true` option to go bottom-up.
 */
declare const getNodeLevels: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeLevelsOptions) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Get the parent of a node at a specific path.
 */
declare const getNodeParent: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Extract the custom properties from a node.
 */
declare const getNodeProps: <N extends TNode>(node: N) => TNodeProps<N>;

/**
 * Get the concatenated text string of a node's content.
 *
 * Note that this will not include spaces or line breaks between block nodes.
 * It is not a user-facing string, but a string for performing offset-related
 * computations for a node.
 */
declare const getNodeString: (node: TNode) => string;

/**
 * Return a generator of all leaf text nodes in a root node.
 */
declare const getNodeTexts: <N extends TextOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeTextsOptions, {
    pass?: ((entry: TNodeEntry<NodeOf<N>>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Return a generator of all the node entries of a root node. Each entry is
 * returned as a `[Node, Path]` tuple, with the path referring to the node's
 * position inside the root node.
 */
declare const getNodes: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeNodesOptions, {
    pass?: ((entry: TNodeEntry<NodeOf<N>>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Check if a descendant node exists at a specific path.
 */
declare const hasNode: (root: TNode, path: Path) => boolean;

declare const hasSingleChild: <N extends TNode>(node: N) => boolean;

/**
 * Check if a value implements the 'Ancestor' interface.
 */
declare const isAncestor: (value: any) => value is TAncestor;

/**
 * Check if a value implements the `Node` interface.
 */
declare const isNode: (value: any) => value is TNode;

/**
 * Check if a value is a list of `Node` objects.
 */
declare const isNodeList: (value: any) => value is TNode[];

/**
 * Check if a node matches a set of props.
 */
declare const nodeMatches: (node: TNode, props: object) => boolean;

type GetNextNodeOptions<V extends Value = Value> = Modify<NonNullable<EditorNextOptions<TDescendant>>, {
    match?: TNodeMatch<ENode<V>>;
}>;
/**
 * Get the matching node in the branch of the document after a location.
 */
declare const getNextNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetNextNodeOptions<V> | undefined) => TNodeEntry<N> | undefined;

type UnhangRangeOptions = EditorUnhangRangeOptions & {
    unhang?: boolean;
};
/**
 * Convert a range into a non-hanging one if:
 * - `unhang` is true,
 * - `at` (default: selection) is a range.
 */
declare const unhangRange: <V extends Value, R extends Path | slate.BasePoint | slate.BaseRange | Span | null | undefined>(editor: TEditor<V>, range: R, options?: UnhangRangeOptions) => R;

type GetNodeEntriesOptions<V extends Value = Value> = Modify<NonNullable<EditorNodesOptions<TNode>>, ENodeMatchOptions<V>> & UnhangRangeOptions;
/**
 * Iterate through all of the nodes in the Editor.
 */
declare const getNodeEntries: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetNodeEntriesOptions<V> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Get the node at a location.
 */
declare const getNodeEntry: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, at: Location, options?: EditorNodeOptions) => TNodeEntry<N> | undefined;

/**
 * Get the parent node of a location.
 * Returns undefined if there is no parent.
 */
declare const getParentNode: <N extends EAncestor<V>, V extends Value = Value>(editor: TEditor<V>, at: Location, options?: EditorParentOptions) => TNodeEntry<N> | undefined;

/**
 * Get the path of a location.
 */
declare const getPath: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorPathOptions) => slate.Path;

/**
 * Get the set of currently tracked path refs of the editor.
 */
declare const getPathRefs: <V extends Value>(editor: TEditor<V>) => Set<slate.PathRef>;

/**
 * Get the start or end point of a location.
 */
declare const getPoint: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorPointOptions) => slate.BasePoint;

/**
 * Get the point after a location.
 */
declare const getPointAfter: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorAfterOptions) => slate.BasePoint | undefined;

/**
 * Get the point before a location.
 */
declare const getPointBefore: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorBeforeOptions) => slate.BasePoint | undefined;

/**
 * Get the set of currently tracked point refs of the editor.
 */
declare const getPointRefs: <V extends Value>(editor: TEditor<V>) => Set<slate.PointRef>;

/**
 * Iterate through all of the positions in the document where a `Point` can be
 * placed.
 *
 * By default it will move forward by individual offsets at a time,  but you
 * can pass the `unit: 'character'` option to moved forward one character, word,
 * or line at at time.
 *
 * Note: By default void nodes are treated as a single point and iteration
 * will not happen inside their content unless you pass in true for the
 * voids option, then iteration will occur.
 */
declare const getPositions: <V extends Value>(editor: TEditor<V>, options?: EditorPositionsOptions) => Generator<slate.BasePoint, void, undefined>;

type GetPreviousNodeOptions<V extends Value = Value> = Modify<NonNullable<EditorPreviousOptions<TNode>>, {
    match?: TNodeMatch<ENode<V>>;
}>;
/**
 * Get the matching node in the branch of the document before a location.
 */
declare const getPreviousNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetPreviousNodeOptions<V> | undefined) => TNodeEntry<N> | undefined;

/**
 * Get a range of a location.
 */
declare const getRange: <V extends Value>(editor: TEditor<V>, at: Location, to?: Location) => slate.BaseRange;

/**
 * Get the set of currently tracked range refs of the editor.
 */
declare const getRangeRefs: <V extends Value>(editor: TEditor<V>) => Set<slate.RangeRef>;

/**
 * Get the start point of a location.
 */
declare const getStartPoint: <V extends Value>(editor: TEditor<V>, at: Location) => slate.BasePoint;

/**
 * Match a void node in the current branch of the editor.
 */
declare const getVoidNode: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, options?: EditorVoidOptions) => TNodeEntry<N> | undefined;

/**
 * Check if a node has block children.
 */
declare const hasBlocks: <V extends Value>(editor: TEditor<V>, element: TElement) => boolean;

/**
 * Check if a node has inline and text children.
 */
declare const hasInlines: <V extends Value>(editor: TEditor<V>, element: TElement) => boolean;

/**
 * Check if a node has text children.
 */
declare const hasTexts: <V extends Value>(editor: TEditor<V>, element: TElement) => boolean;

/**
 * Insert a block break at the current selection.
 *
 * If the selection is currently expanded, it will be deleted first.
 */
declare const insertBreak: <V extends Value>(editor: TEditor<V>) => void;

/**
 * Insert a node at the current selection.
 *
 * If the selection is currently expanded, it will be deleted first.
 */
declare const insertNode: <V extends Value>(editor: TEditor<V>, node: EElementOrText<V> | EElementOrText<V>[]) => void;

/**
 * Check if a value is a block `Element` object.
 */
declare const isBlock: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/**
 * Check if a point is an edge of a location.
 */
declare const isEdgePoint: <V extends Value>(editor: TEditor<V>, point: Point, at: Location) => boolean;

/**
 * Check if a value is an `Editor` object.
 */
declare const isEditor: (value: any) => value is TEditor;

/**
 * Check if the editor is currently normalizing after each operation.
 */
declare const isEditorNormalizing: <V extends Value>(editor: TEditor<V>) => boolean;

/**
 * Check if an element is empty, accounting for void nodes.
 */
declare const isElementEmpty: <V extends Value>(editor: TEditor<V>, element: EElement<V>) => boolean;

/**
 * Check if a point is the end point of a location.
 * If point is null, return false.
 */
declare const isEndPoint: <V extends Value>(editor: TEditor<V>, point: Point | null | undefined, at: Location) => boolean;

/**
 * Check if a value is an inline `Element` object.
 */
declare const isInline: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/**
 * Check if a value is a markable void `Element` object.
 */
declare const isMarkableVoid: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/**
 * Check if a point is the start point of a location.
 * If point is null, return false.
 */
declare const isStartPoint: <V extends Value>(editor: TEditor<V>, point: Point | null | undefined, at: Location) => boolean;

/**
 * Check if a value is a void `Element` object.
 */
declare const isVoid: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/**
 * Normalize any dirty objects in the editor.
 */
declare const normalizeEditor: <V extends Value>(editor: TEditor<V>, options?: EditorNormalizeOptions) => void;

/**
 * Remove a custom property from all of the leaf text nodes in the current
 * selection.
 *
 * If the selection is currently collapsed, the removal will be stored on
 * `editor.marks` and applied to the text inserted next.
 */
declare const removeEditorMark: <V extends Value>(editor: TEditor<V>, key: string) => void;

/**
 * Call a function, deferring normalization until after it completes
 * @return true if normalized.
 */
declare const withoutNormalizing: <V extends Value>(editor: TEditor<V>, fn: () => boolean | void) => boolean;

/**
 * Check if an element matches set of properties.
 *
 * Note: this checks custom properties, and it does not ensure that any
 * children are equivalent.
 */
declare const elementMatches: (element: TElement, props: object) => boolean;

/**
 * Check if a value implements the 'Element' interface.
 */
declare const isElement: (value: any) => value is TElement;

/**
 * Check if a value is an array of `Element` objects.
 */
declare const isElementList: (value: any) => value is TElement[];

type THistoryEditor<V extends Value = Value> = TEditor<V> & Pick<HistoryEditor, 'history' | 'undo' | 'redo'>;

/**
 * {@link HistoryEditor.isHistoryEditor}
 */
declare const isHistoryEditor: (value: any) => value is THistoryEditor;

/**
 * {@link HistoryEditor.isMerging}
 */
declare const isHistoryMerging: <V extends Value>(editor: THistoryEditor<V>) => boolean | undefined;

/**
 * {@link HistoryEditor.isSaving}
 */
declare const isHistorySaving: <V extends Value>(editor: THistoryEditor<V>) => boolean | undefined;

/**
 * {@link HistoryEditor.withoutMerging}
 */
declare const withoutMergingHistory: <V extends Value>(editor: THistoryEditor<V>, fn: () => void) => void;

/**
 * {@link HistoryEditor.withoutSaving}
 */
declare const withoutSavingHistory: <V extends Value>(editor: THistoryEditor<V>, fn: () => void) => void;

/**
 * See {@link Range.isCollapsed}.
 * Return false if `range` is not defined.
 */
declare const isCollapsed: (range?: Range | null) => boolean;

/**
 * See {@link Range.isExpanded}.
 * Return false if `range` is not defined.
 */
declare const isExpanded: (range?: Range | null) => boolean;

/**
 * Check if a value implements the `Text` interface.
 */
declare const isText: (value: any) => value is TText;

/**
 * Check if a value is a list of `Text` objects.
 */
declare const isTextList: (value: any) => value is TText[];

/**
 * Check if two text nodes are equal.
 */
declare const textEquals: (text: TText, another: TText) => boolean;

/**
 * Check if an text matches set of properties.
 *
 * Note: this is for matching custom properties, and it does not ensure that
 * the `text` property are two nodes equal.
 */
declare const textMatches: <T extends TText>(text: T, props: object) => boolean;

/**
 * Collapse the selection.
 */
declare const collapseSelection: <V extends Value>(editor: TEditor<V>, options?: SelectionCollapseOptions) => void;

/**
 * Delete content in the editor.
 */
declare const deleteText: <V extends Value>(editor: TEditor<V>, options?: TextDeleteOptions) => void;

/**
 * Unset the selection.
 */
declare const deselect: <V extends Value>(editor: TEditor<V>) => void;

/**
 * Insert a fragment at a specific location in the editor.
 */
declare const insertFragment: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, fragment: N[], options?: TextInsertFragmentOptions) => void;

interface NodeMatchOption<V extends Value> {
    match?: TNodeMatch<ENode<V>>;
}

/**
 * Filter nodes.
 */
interface QueryNodeOptions {
    /**
     * Query the node entry.
     */
    filter?: <N extends TNode>(entry: TNodeEntry<N>) => boolean;
    /**
     * List of types that are valid. If empty or undefined - allow all.
     */
    allow?: string[] | string | null;
    /**
     * List of types that are invalid.
     */
    exclude?: string[] | string | null;
    /**
     * Valid path levels.
     */
    level?: number[] | number | null;
    /**
     * Paths above that value are invalid.
     */
    maxLevel?: number | null;
}

/**
 * Query the editor state.
 */
interface QueryEditorOptions<V extends Value = Value, E extends TEditor<V> = TEditor<V>> extends Pick<QueryNodeOptions, 'allow' | 'exclude'> {
    /**
     * Query the editor.
     */
    filter?: (editor: E) => boolean;
    /**
     * Location from where to lookup the node types (bottom-up)
     */
    at?: Location;
    /**
     * When the selection is at the start of the block above.
     */
    selectionAtBlockStart?: boolean;
    /**
     * When the selection is at the end of the block above.
     */
    selectionAtBlockEnd?: boolean;
}

type InsertNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.insertNodes>[2]>, NodeMatchOption<V>> & {
    /**
     * Remove the currect block if empty before inserting. Only applies to
     * paragraphs by default, but can be customized by passing a
     * QueryNodeOptions object.
     */
    removeEmpty?: boolean | QueryNodeOptions;
    /**
     * Insert the nodes after the currect block. Does not apply if the
     * removeEmpty option caused the current block to be removed.
     */
    nextBlock?: boolean;
};
/**
 * Insert nodes at a specific location in the Editor.
 */
declare const insertNodes: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, nodes: N | N[], { nextBlock, removeEmpty, ...options }?: InsertNodesOptions<V>) => void;

/**
 * Insert a string of text in the Editor.
 */
declare const insertText: <V extends Value>(editor: TEditor<V>, text: string, options?: TextInsertTextOptions) => void;

type LiftNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.liftNodes>[1]>, NodeMatchOption<V>>;
/**
 * Lift nodes at a specific location upwards in the document tree, splitting
 * their parent in two if necessary.
 */
declare const liftNodes: <V extends Value>(editor: TEditor<V>, options?: LiftNodesOptions<V> | undefined) => void;

type MergeNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>, NodeMatchOption<V>> & {
    /**
     * Default: if the node isn't already the next sibling of the previous node, move
     * it so that it is before merging.
     */
    mergeNode?: (editor: TEditor<V>, options: {
        at: Path;
        to: Path;
    }) => void;
    /**
     * Default: if there was going to be an empty ancestor of the node that was merged,
     * we remove it from the tree.
     */
    removeEmptyAncestor?: (editor: TEditor<V>, options: {
        at: Path;
    }) => void;
};
/**
 * Merge a node at a location with the previous node of the same depth,
 * removing any empty containing nodes after the merge if necessary.
 */
declare const mergeNodes: <V extends Value>(editor: TEditor<V>, options?: MergeNodesOptions<V>) => void;

type MoveNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.moveNodes>[1]>, NodeMatchOption<V>>;
/**
 * Move the nodes at a location to a new location.
 */
declare const moveNodes: <V extends Value>(editor: TEditor<V>, options?: MoveNodesOptions<V> | undefined) => void;

/**
 * Move the selection's point forward or backward.
 */
declare const moveSelection: <V extends Value>(editor: TEditor<V>, options?: SelectionMoveOptions) => void;

type RemoveNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.removeNodes>[1]>, NodeMatchOption<V>>;
/**
 * Remove the nodes at a specific location in the document.
 */
declare const removeNodes: <V extends Value>(editor: TEditor<V>, options?: RemoveNodesOptions<V> | undefined) => void;

/**
 * Set the selection to a new value.
 */
declare const select: <V extends Value>(editor: TEditor<V>, target: Location) => void;

type SetNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.setNodes>[2]>, NodeMatchOption<V>>;
/**
 * Set new properties on the nodes at a location.
 */
declare const setNodes: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, props: Partial<TNodeProps<N>>, options?: SetNodesOptions<V> | undefined) => void;

/**
 * Set new properties on one of the selection's points.
 */
declare const setPoint: <V extends Value>(editor: TEditor<V>, props: Partial<Point>, options?: SelectionSetPointOptions) => void;

/**
 * Set new properties on the selection.
 */
declare const setSelection: <V extends Value>(editor: TEditor<V>, props: Partial<Range>) => void;

type SplitNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.splitNodes>[1]>, NodeMatchOption<V>>;
/**
 * Split the nodes at a specific location.
 */
declare const splitNodes: <V extends Value>(editor: TEditor<V>, options?: SplitNodesOptions<V> | undefined) => void;

type UnsetNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>, NodeMatchOption<V>>;
/**
 * Unset properties on the nodes at a location.
 */
declare const unsetNodes: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, props: keyof TNodeProps<N> | (keyof TNodeProps<N>)[], options?: UnsetNodesOptions<V> | undefined) => void;

type UnwrapNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>, ENodeMatchOptions<V>>;
/**
 * Unwrap the nodes at a location from a parent node, splitting the parent if
 * necessary to ensure that only the content in the range is unwrapped.
 */
declare const unwrapNodes: <V extends Value>(editor: TEditor<V>, options?: UnwrapNodesOptions<V> | undefined) => void;

type WrapNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>, NodeMatchOption<V>>;
/**
 * Wrap the nodes at a location in a new container node, splitting the edges
 * of the range first to ensure that only the content in the range is wrapped.
 */
declare const wrapNodes: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, element: N, options?: WrapNodesOptions<V> | undefined) => void;

type FindNodeOptions<V extends Value = Value> = GetNodeEntriesOptions<V>;
/**
 * Find node matching the condition.
 */
declare const findNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: FindNodeOptions<V>) => TNodeEntry<N> | undefined;

/**
 * Iterate through all of the nodes in the editor and break early for the first truthy match. Otherwise
 * returns false.
 */
declare const someNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options: FindNodeOptions<V>) => boolean;

/**
 * Add marks to each node of a range.
 */
declare const addRangeMarks: <V extends Value>(editor: TEditor<V>, props: any, { at, }?: {
    at?: Location | null | undefined;
}) => void;

declare const setElements: <V extends Value>(editor: TEditor<V>, props: Partial<TNodeProps<TElement>>, options?: SetNodesOptions) => void;

/**
 * Unhang the range of length 1 so both edges are in the same text node.
 */
declare const unhangCharacterRange: <V extends Value>(editor: TEditor<V>, at: Range) => {
    anchor: slate.BasePoint;
    focus: slate.BasePoint;
};

/**
 * Query the node entry.
 */
declare const queryNode: <N extends TNode>(entry?: TNodeEntry<N> | undefined, { filter, allow, exclude, level, maxLevel }?: QueryNodeOptions) => boolean;

export { AncestorOf, ChildOf, DescendantOf, EAncestor, EAncestorEntry, EDescendant, EDescendantEntry, EElement, EElementEntry, EElementOrText, EMarks, ENode, ENodeEntry, ENodeMatch, ENodeMatchOptions, EText, ETextEntry, ElementOf, FindNodeOptions, GetAboveNodeOptions, GetLevelsOptions, GetNextNodeOptions, GetNodeEntriesOptions, GetPreviousNodeOptions, InsertNodesOptions, LiftNodesOptions, MarkKeysOf, MarksOf, MergeNodesOptions, MoveNodesOptions, NodeMatchOption, NodeOf, Predicate, PredicateFn, PredicateObj, QueryEditorOptions, QueryNodeOptions, RemoveNodesOptions, SetNodesOptions, SplitNodesOptions, TAncestor, TAncestorEntry, TDescendant, TDescendantEntry, TEditor, TElement, TElementEntry, THistoryEditor, TInsertNodeOperation, TInsertTextOperation, TLocation, TMergeNodeOperation, TMoveNodeOperation, TNode, TNodeChildEntry, TNodeEntry, TNodeMatch, TNodeOperation, TNodeProps, TOperation, TPath, TRange, TRemoveNodeOperation, TRemoveTextOperation, TSelection, TSelectionOperation, TSetNodeOperation, TSetSelectionOperation, TSpan, TSplitNodeOperation, TText, TTextEntry, TTextOperation, TextOf, UnhangRangeOptions, UnsetNodesOptions, UnwrapNodesOptions, Value, ValueOf, WrapNodesOptions, addMark, addRangeMarks, collapseSelection, createPathRef, createPointRef, createRangeRef, createTEditor, deleteBackward, deleteForward, deleteFragment, deleteMerge, deleteText, deselect, elementMatches, findNode, getAboveNode, getCommonNode, getEdgePoints, getEditorString, getEndPoint, getFirstNode, getFragment, getLastNode, getLeafNode, getLevels, getMarks, getNextNode, getNode, getNodeAncestor, getNodeAncestors, getNodeChild, getNodeChildren, getNodeDescendant, getNodeDescendants, getNodeElements, getNodeEntries, getNodeEntry, getNodeFirstNode, getNodeFragment, getNodeLastNode, getNodeLeaf, getNodeLevels, getNodeParent, getNodeProps, getNodeString, getNodeTexts, getNodes, getParentNode, getPath, getPathRefs, getPoint, getPointAfter, getPointBefore, getPointRefs, getPositions, getPreviousNode, getQueryOptions, getRange, getRangeRefs, getStartPoint, getTEditor, getVoidNode, hasBlocks, hasInlines, hasNode, hasSingleChild, hasTexts, insertBreak, insertFragment, insertNode, insertNodes, insertText, isAncestor, isBlock, isCollapsed, isDescendant, isEdgePoint, isEditor, isEditorNormalizing, isElement, isElementEmpty, isElementList, isEndPoint, isExpanded, isHistoryEditor, isHistoryMerging, isHistorySaving, isInline, isMarkableVoid, isNode, isNodeList, isStartPoint, isText, isTextList, isVoid, liftNodes, match, mergeNodes, moveNodes, moveSelection, nodeMatches, normalizeEditor, queryNode, removeEditorMark, removeNodes, select, setElements, setNodes, setPoint, setSelection, someNode, splitNodes, textEquals, textMatches, unhangCharacterRange, unhangRange, unsetNodes, unwrapNodes, withoutMergingHistory, withoutNormalizing, withoutSavingHistory, wrapNodes };
