declare const IS_APPLE: boolean;

declare const escapeRegExp: (text: string) => string;

declare const findHtmlParentElement: (el: HTMLElement | null, nodeName: string) => HTMLElement | null;

/**
 * Call a handler if defined
 */
declare const getHandler: <T extends (...args: any) => any>(cb?: T | undefined, ...args: Parameters<T>) => () => void;

declare const hexToBase64: (hex: string) => string;

/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */
/**
 * Loosely validate a URL `string`.
 */
declare const isUrl: (string: any) => boolean;

/**
 * Merge props by composing handlers.
 */
declare const mergeProps: <T>(props?: T | undefined, overrideProps?: T | undefined, { handlerKeys, handlerQuery, }?: {
    /**
     * The keys of the handlers to merge.
     */
    handlerKeys?: string[] | undefined;
    /**
     * A function that returns true if it's a handler to merge.
     *
     * Default: keys having `on` prefix.
     */
    handlerQuery?: ((key: string) => boolean) | null | undefined;
}) => T;

interface SanitizeUrlOptions {
    allowedSchemes?: string[];
    permitInvalid?: boolean;
}
declare const sanitizeUrl: (url: string | undefined, { allowedSchemes, permitInvalid }: SanitizeUrlOptions) => string | null;

/**
 * @returns whether the provided parameter is undefined.
 */
declare const isUndefined: (obj: any) => obj is undefined;
declare const isNull: (obj: any) => obj is null;
/**
 * @returns whether the provided parameter is undefined or null.
 */
declare const isUndefinedOrNull: (obj: any) => obj is null | undefined;
/**
 * @returns whether the provided parameter is defined.
 */
declare const isDefined: <T>(arg: T | null | undefined) => arg is T;

type AnyObject = {
    [key: string]: any;
};
interface UnknownObject {
    [key: string]: unknown;
}
/**
 * Any function.
 */
type AnyFunction = (...args: any) => any;

declare type DeepPartial<T> = T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    [key in keyof T]: T[key];
} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : T;

/**
 * Get the property names from an interface which are functions
 */
type FunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
/**
 * Get the properties from an interface which are functions
 */
type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;

type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

type WithRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
/** Makes each property optional and turns each leaf property into any, allowing for type overrides by narrowing any. */
type DeepPartialAny<T> = {
    [P in keyof T]?: T[P] extends AnyObject ? DeepPartialAny<T[P]> : any;
};
/**
 * Simplify a complex type expression into a single object.
 */
type Simplify<T> = T extends any[] | Date ? T : {
    [K in keyof T]: T[K];
} & {};
/**
 * Turn a union type into an intersection.
 */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
/**
 * Modify type properties.
 * https://stackoverflow.com/a/55032655/6689201
 */
type Modify<T, R> = Omit<T, keyof R> & R;
/**
 * Modify deep type properties.
 * https://stackoverflow.com/a/65561287/6689201
 */
type ModifyDeep<A extends AnyObject, B extends DeepPartialAny<A>> = {
    [K in keyof A]: B[K] extends never ? A[K] : B[K] extends AnyObject ? ModifyDeep<A[K], B[K]> : B[K];
} & (A extends AnyObject ? Omit<B, keyof A> : A);
type PartialPick<T, K extends keyof T> = {
    [P in K]?: T[P];
};
type WithPartial<T, K extends keyof T> = Omit<T, K> & Partial<T>;

export { AnyFunction, AnyObject, DeepPartial, DeepPartialAny, FunctionProperties, FunctionPropertyNames, IS_APPLE, Modify, ModifyDeep, PartialPick, SanitizeUrlOptions, Simplify, UnionToIntersection, UnknownObject, WithOptional, WithPartial, WithRequired, escapeRegExp, findHtmlParentElement, getHandler, hexToBase64, isDefined, isNull, isUndefined, isUndefinedOrNull, isUrl, mergeProps, sanitizeUrl };
